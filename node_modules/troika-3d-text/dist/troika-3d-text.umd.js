(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('troika-three-text'), require('troika-3d'), require('three')) :
  typeof define === 'function' && define.amd ? define(['exports', 'troika-three-text', 'troika-3d', 'three'], factory) :
  (global = global || self, factory(global.troika_3d_text = {}, global.troika_three_text, global.troika_3d, global.THREE));
}(this, (function (exports, troikaThreeText, troika3d, three) { 'use strict';

  var tempVec4 = new three.Vector4();

  function getMesh() {
    var material = troika3d.createDerivedMaterial(
      new three.MeshBasicMaterial({
        transparent: true,
        opacity: 0.3,
        depthWrite: false
      }),
      {
        uniforms: {
          rect: {value: new three.Vector4()}
        },
        vertexDefs: "uniform vec4 rect;",
        vertexTransform: "\n  position.x = position.x < 0.0 ? rect.x : rect.z;\n  position.y = position.y < 0.0 ? rect.w : rect.y;\n  "
      }
    );
    material.instanceUniforms = ['rect', 'diffuse'];
    var mesh = new three.Mesh(
      new three.BoxBufferGeometry().translate(0, 0, -0.5), //origin on front face for distance sorting
      material
    );
    return (getMesh = function () { return mesh; })()
  }


  // TODO make instanceable or a single updated geometry to limit to a single draw call

  var RangeRectFacade = /*@__PURE__*/(function (Instanceable3DFacade) {
    function RangeRectFacade (parent) {
      Instanceable3DFacade.call(this, parent);
      this.instancedThreeObject = getMesh();
      this._color = new three.Color();
      this._rect = new three.Vector4();
    }

    if ( Instanceable3DFacade ) RangeRectFacade.__proto__ = Instanceable3DFacade;
    RangeRectFacade.prototype = Object.create( Instanceable3DFacade && Instanceable3DFacade.prototype );
    RangeRectFacade.prototype.constructor = RangeRectFacade;

    RangeRectFacade.prototype.afterUpdate = function afterUpdate () {
      var ref = this;
      var top = ref.top;
      var right = ref.right;
      var bottom = ref.bottom;
      var left = ref.left;
      var color = ref.color;
      if (!this._color.equals(color)) {
        this.setInstanceUniform('diffuse', this._color = new three.Color(color));
      }

      if (!this._rect.equals(tempVec4.set(left, top, right, bottom))) {
        this.setInstanceUniform('rect', tempVec4.clone());
      }
      Instanceable3DFacade.prototype.afterUpdate.call(this);
    };

    RangeRectFacade.prototype.getBoundingSphere = function getBoundingSphere () {
      return null
    };

    return RangeRectFacade;
  }(troika3d.Instanceable3DFacade));

  var THICKNESS = 0.25; //rect depth as percentage of height

  var tempMat4 = new three.Matrix4();
  var tempPlane = new three.Plane();
  var tempVec3 = new three.Vector3();
  var noClip = Object.freeze([-Infinity, -Infinity, Infinity, Infinity]);

  /**
   * Manager facade for selection rects and user selection behavior
   */
  var SelectionManagerFacade = /*@__PURE__*/(function (ListFacade) {
    function SelectionManagerFacade (parent, onSelectionChange) {
      var this$1 = this;

      ListFacade.call(this, parent);
      var textMesh = parent.threeObject;

      this.rangeColor = 0x00ccff;
      this.clipRect = noClip;

      this.template = {
        key: function (d, i) { return ("rect" + i); },
        facade: RangeRectFacade,
        top: function (d) { return clamp(d.top, this$1.clipRect[1], this$1.clipRect[3]); },
        right: function (d) { return clamp(d.right, this$1.clipRect[0], this$1.clipRect[2]); },
        bottom: function (d) { return clamp(d.bottom, this$1.clipRect[1], this$1.clipRect[3]); },
        left: function (d) { return clamp(d.left, this$1.clipRect[0], this$1.clipRect[2]); },
        z: function (d) { return (d.top - d.bottom) * THICKNESS / 2; },
        scaleZ: function (d) { return (d.top - d.bottom) * THICKNESS; },
        color: function (d) { return this$1.rangeColor; },
        visible: function (d) {
          var r = this$1.clipRect;
          return d.right > r[0] && d.top > r[1] && d.left < r[2] && d.bottom < r[3]
        },
        renderOrder: function (d) { return this$1.renderOrder || 0; }
      };

      var onDragStart = function (e) {
        var textRenderInfo = this$1.textRenderInfo;
        if (textRenderInfo) {
          var localPoint = e.intersection.point.clone().applyMatrix4(tempMat4.getInverse(textMesh.matrixWorld));
          var caret = troikaThreeText.getCaretAtPoint(textRenderInfo, localPoint.x, localPoint.y);
          if (caret) {
            onSelectionChange(caret.charIndex, caret.charIndex);
            parent.addEventListener('drag', onDrag);
            parent.addEventListener('dragend', onDragEnd);
          }
          e.preventDefault();
        }
      };

      var onDrag = function (e) {
        var textRenderInfo = textMesh.textRenderInfo;
        if (e.ray && textRenderInfo) {
          // Raycast to an infinite plane so dragging outside the text bounds will work
          var ray = e.ray.clone().applyMatrix4(tempMat4.getInverse(textMesh.matrixWorld));
          var localPoint = ray.intersectPlane(tempPlane.setComponents(0, 0, 1, 0), tempVec3);
          if (localPoint) {
            var caret = troikaThreeText.getCaretAtPoint(textRenderInfo, localPoint.x, localPoint.y);
            if (caret) {
              onSelectionChange(this$1.selectionStart, caret.charIndex);
            }
          }
          e.preventDefault();
        }
      };

      var onDragEnd = function (e) {
        parent.removeEventListener('drag', onDrag);
        parent.removeEventListener('dragend', onDragEnd);
      };

      parent.addEventListener('dragstart', onDragStart);
      parent.addEventListener('mousedown', onDragStart);

      this._cleanupEvents = function () {
        onDragEnd();
        parent.removeEventListener('dragstart', onDragStart);
        parent.removeEventListener('mousedown', onDragStart);
      };
    }

    if ( ListFacade ) SelectionManagerFacade.__proto__ = ListFacade;
    SelectionManagerFacade.prototype = Object.create( ListFacade && ListFacade.prototype );
    SelectionManagerFacade.prototype.constructor = SelectionManagerFacade;

    var prototypeAccessors = { clipRect: { configurable: true } };

    SelectionManagerFacade.prototype.afterUpdate = function afterUpdate () {
      this.data = troikaThreeText.getSelectionRects(this.textRenderInfo, this.selectionStart, this.selectionEnd);
      ListFacade.prototype.afterUpdate.call(this);
    };

    // normalize clipRect
    prototypeAccessors.clipRect.set = function (clipRect) {
      this._clipRect = (clipRect && Array.isArray(clipRect) && clipRect.length === 4) ? clipRect : noClip;
    };
    prototypeAccessors.clipRect.get = function () {
      return this._clipRect
    };

    SelectionManagerFacade.prototype.destructor = function destructor () {
      this._cleanupEvents();
      ListFacade.prototype.destructor.call(this);
    };

    Object.defineProperties( SelectionManagerFacade.prototype, prototypeAccessors );

    return SelectionManagerFacade;
  }(troika3d.ListFacade));

  function clamp(val, min, max) {
    return Math.min(max, Math.max(min, val))
  }

  // Properties that will simply be forwarded to the TextMesh:
  var TEXT_MESH_PROPS = [
    'text',
    'anchorX',
    'anchorY',
    'font',
    'fontSize',
    'letterSpacing',
    'lineHeight',
    'maxWidth',
    'overflowWrap',
    'textAlign',
    'textIndent',
    'whiteSpace',
    'material',
    'color',
    'colorRanges',
    'outlineWidth',
    'outlineColor',
    'depthOffset',
    'clipRect',
    'orientation',
    'glyphGeometryDetail',
    'sdfGlyphSize',
    'debugSDF'
  ];


  /**
   * Facade wrapper for a TextMesh. All configuration properties of TextMesh
   * are accepted and proxied through directly.
   */
  var Text3DFacade = /*@__PURE__*/(function (Object3DFacade) {
    function Text3DFacade(parent) {
      var this$1 = this;

      var mesh = new troikaThreeText.Text();
      mesh.geometry.boundingSphere.version = 0;
      Object3DFacade.call(this, parent, mesh);

      /* TODO mirroring to DOM...?
      const el = this._domEl = document.createElement('section')
      el.style = 'position:fixed;left:-99px;overflow:hidden;width:10px;height:10px;'
      document.body.appendChild(el) //should insert into local element
      */

      this.selectable = false;
      this.selectionStart = this.selectionEnd = -1;
      this.onSyncStart = null;
      this.onSyncComplete = null;

      mesh.addEventListener('syncstart', function (e) {
        this$1.notifyWorld('text3DSyncStart');
        if (this$1.onSyncStart) {
          this$1.onSyncStart();
        }
      });
      mesh.addEventListener('synccomplete', function (e) {
        if (!this$1.isDestroying) {
          mesh.geometry.boundingSphere.version++;
          this$1.afterUpdate();
          this$1.notifyWorld('text3DSyncComplete');
          this$1.notifyWorld('needsRender');
          if (this$1.onSyncComplete) {
            this$1.onSyncComplete();
          }
        }
      });
    }

    if ( Object3DFacade ) Text3DFacade.__proto__ = Object3DFacade;
    Text3DFacade.prototype = Object.create( Object3DFacade && Object3DFacade.prototype );
    Text3DFacade.prototype.constructor = Text3DFacade;

    var prototypeAccessors = { textRenderInfo: { configurable: true } };

    prototypeAccessors.textRenderInfo.get = function () {
      return this.threeObject.textRenderInfo
    };

    Text3DFacade.prototype.afterUpdate = function afterUpdate () {
      var this$1 = this;

      var textMesh = this.threeObject;
      TEXT_MESH_PROPS.forEach(function (prop) {
        textMesh[prop] = this$1[prop];
      });
      textMesh.sync();

      Object3DFacade.prototype.afterUpdate.call(this);

      if (this.text !== this._prevText) {
        // TODO mirror to DOM... this._domEl.textContent = this.text
        // Clear selection when text changes
        this.selectionStart = this.selectionEnd = -1;
        this._prevText = this.text;
      }

      this._updateSelection();
    };

    Text3DFacade.prototype._updateSelection = function _updateSelection () {
      var this$1 = this;

      var ref = this;
      var selectable = ref.selectable;
      var selectionStart = ref.selectionStart;
      var selectionEnd = ref.selectionEnd;
      var selFacade = this._selectionFacade;
      if (selectable !== this._selectable) {
        this._selectable = selectable;
        if (selectable) {
          selFacade = this._selectionFacade = new SelectionManagerFacade(this, function (start, end) {
            this$1.selectionStart = start;
            this$1.selectionEnd = end;
            this$1._updateSelection();
            this$1.notifyWorld('needsRender');
          });
        } else {
          if (selFacade) {
            selFacade.destructor();
            selFacade = this._selectionFacade = null;
          }
          this.selectionStart = this.selectionEnd = -1;
        }
      }
      if (selFacade) {
        selFacade.textRenderInfo = this.threeObject.textRenderInfo;
        selFacade.selectionStart = selectionStart;
        selFacade.selectionEnd = selectionEnd;
        selFacade.clipRect = this.clipRect;
        selFacade.renderOrder = this.renderOrder;
        selFacade.afterUpdate();
      }

      /* TODO update selection in DOM...
      const {selectionStart, selectionEnd} = this
      if (selectionStart !== this._prevSelStart || selectionEnd !== this._prevSelEnd) {
        this._prevSelStart = selectionStart
        this._prevSelEnd = selectionEnd
        const sel = document.getSelection()
        sel.removeAllRanges()
        if (this.selectable && selectionStart > -1 && selectionEnd > selectionStart) {
          const range = document.createRange()
          range.setStart(this._domEl.firstChild, this.selectionStart)
          range.setEnd(this._domEl.firstChild, this.selectionEnd)
          sel.addRange(range)
        }
      }
      */
    };

    Text3DFacade.prototype.destructor = function destructor () {
      this.threeObject.dispose();
      //this._domEl.parentNode.removeChild(this._domEl)
      if (this._selectionFacade) {
        this._selectionFacade.destructor();
      }
      Object3DFacade.prototype.destructor.call(this);
    };

    Object.defineProperties( Text3DFacade.prototype, prototypeAccessors );

    return Text3DFacade;
  }(troika3d.Object3DFacade));

  Object.defineProperty(exports, 'GlyphsGeometry', {
    enumerable: true,
    get: function () {
      return troikaThreeText.GlyphsGeometry;
    }
  });
  Object.defineProperty(exports, 'TextMesh', {
    enumerable: true,
    get: function () {
      return troikaThreeText.Text;
    }
  });
  Object.defineProperty(exports, 'configureTextBuilder', {
    enumerable: true,
    get: function () {
      return troikaThreeText.configureTextBuilder;
    }
  });
  Object.defineProperty(exports, 'fontProcessorWorkerModule', {
    enumerable: true,
    get: function () {
      return troikaThreeText.fontProcessorWorkerModule;
    }
  });
  Object.defineProperty(exports, 'getCaretAtPoint', {
    enumerable: true,
    get: function () {
      return troikaThreeText.getCaretAtPoint;
    }
  });
  Object.defineProperty(exports, 'getSelectionRects', {
    enumerable: true,
    get: function () {
      return troikaThreeText.getSelectionRects;
    }
  });
  Object.defineProperty(exports, 'preloadFont', {
    enumerable: true,
    get: function () {
      return troikaThreeText.preloadFont;
    }
  });
  exports.Text3DFacade = Text3DFacade;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
