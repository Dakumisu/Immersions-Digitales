{"id":"node_modules/glsl-directional-light/index.glsl","dependencies":[{"name":"E:\\MMI\\PTUT\\Site-ID\\package.json","includedInParent":true,"mtime":1609891155693},{"name":"E:\\MMI\\PTUT\\Site-ID\\node_modules\\glsl-directional-light\\package.json","includedInParent":true,"mtime":1609890944866}],"generated":{"js":"module.exports=\"#define GLSLIFY 1\\n/**\\n * Directional Light.\\n *\\n * One of the simplest forms of dynamic lighting – casts\\n * a light across a surface from a particular direction,\\n * but not a particular point. Generally useful for rendering\\n * daylight.\\n *\\n * Adapted for glslify from implementation in three.js:\\n * http://git.io/u7FWKw\\n *\\n * @param {vec3} normal   This point's normal vector.\\n * @param {vec3} light    The light color.\\n * @param {vec3} surface  The color of the material/surface being drawn.\\n *\\n * @param {vec3} lightDirection The direction of the light to cast – normalized.\\n * @param {mat4} modelMatrix    The model matrix.\\n * @param {mat4} viewMatrix     The view matrix.\\n * @param {vec3} viewPosition   The position of the camera in world space.\\n *\\n * The following parameters are optional, but must be specified together:\\n *\\n * @param {float} shininess   Set to lower values for matte, higher for gloss.\\n * @param {float} specularity The amount by which to scale the specular light\\n *                            cast on the object.\\n *\\n * @return {vec3} The color of the light to cast on this point.\\n */\\nvec3 directional_light(\\n    vec3 normal\\n  , vec3 light\\n  , vec3 surface\\n  , vec3 lightDirection\\n\\n  , mat4 modelMatrix\\n  , mat4 viewMatrix\\n  , vec3 viewPosition\\n\\n  , float shininess\\n  , float specularity\\n) {\\n  vec3 direction = normalize((\\n    vec4(lightDirection, 1.0)\\n  ).xyz);\\n\\n  vec3 halfDirection = normalize(\\n    direction + viewPosition\\n  );\\n\\n  vec3 tNormal = normalize((\\n    modelMatrix * vec4(normal, 1.0)\\n  ).xyz);\\n\\n  float diffuse = max(dot(tNormal, direction), 0.0);\\n  float halfDot = max(dot(tNormal, halfDirection), 0.0);\\n  float specular = max(pow(halfDot, shininess), 0.0);\\n\\n  return max(light * (\\n    diffuse * surface +\\n    diffuse * specular * specularity\\n  ), vec3(0.0));\\n}\\n\\nvec3 directional_light(\\n    vec3 normal\\n  , vec3 light\\n  , vec3 surface\\n  , vec3 lightDirection\\n\\n  , mat4 modelMatrix\\n  , mat4 viewMatrix\\n  , vec3 viewPosition\\n) {\\n  vec3 direction = normalize((\\n    modelMatrix * vec4(lightDirection, 1.0)\\n  ).xyz);\\n\\n  float diffuse = max(\\n    dot(normal, direction)\\n  , 0.0);\\n\\n  return max(\\n    light * diffuse * surface\\n  , vec3(0.0));\\n}\\n\\n\";"},"sourceMaps":{"js":{"mappings":[{"source":"node_modules/glsl-directional-light/index.glsl","original":{"line":1,"column":0},"generated":{"line":1,"column":0}}],"sources":{"node_modules/glsl-directional-light/index.glsl":"module.exports=\"#define GLSLIFY 1\\n/**\\n * Directional Light.\\n *\\n * One of the simplest forms of dynamic lighting – casts\\n * a light across a surface from a particular direction,\\n * but not a particular point. Generally useful for rendering\\n * daylight.\\n *\\n * Adapted for glslify from implementation in three.js:\\n * http://git.io/u7FWKw\\n *\\n * @param {vec3} normal   This point's normal vector.\\n * @param {vec3} light    The light color.\\n * @param {vec3} surface  The color of the material/surface being drawn.\\n *\\n * @param {vec3} lightDirection The direction of the light to cast – normalized.\\n * @param {mat4} modelMatrix    The model matrix.\\n * @param {mat4} viewMatrix     The view matrix.\\n * @param {vec3} viewPosition   The position of the camera in world space.\\n *\\n * The following parameters are optional, but must be specified together:\\n *\\n * @param {float} shininess   Set to lower values for matte, higher for gloss.\\n * @param {float} specularity The amount by which to scale the specular light\\n *                            cast on the object.\\n *\\n * @return {vec3} The color of the light to cast on this point.\\n */\\nvec3 directional_light(\\n    vec3 normal\\n  , vec3 light\\n  , vec3 surface\\n  , vec3 lightDirection\\n\\n  , mat4 modelMatrix\\n  , mat4 viewMatrix\\n  , vec3 viewPosition\\n\\n  , float shininess\\n  , float specularity\\n) {\\n  vec3 direction = normalize((\\n    vec4(lightDirection, 1.0)\\n  ).xyz);\\n\\n  vec3 halfDirection = normalize(\\n    direction + viewPosition\\n  );\\n\\n  vec3 tNormal = normalize((\\n    modelMatrix * vec4(normal, 1.0)\\n  ).xyz);\\n\\n  float diffuse = max(dot(tNormal, direction), 0.0);\\n  float halfDot = max(dot(tNormal, halfDirection), 0.0);\\n  float specular = max(pow(halfDot, shininess), 0.0);\\n\\n  return max(light * (\\n    diffuse * surface +\\n    diffuse * specular * specularity\\n  ), vec3(0.0));\\n}\\n\\nvec3 directional_light(\\n    vec3 normal\\n  , vec3 light\\n  , vec3 surface\\n  , vec3 lightDirection\\n\\n  , mat4 modelMatrix\\n  , mat4 viewMatrix\\n  , vec3 viewPosition\\n) {\\n  vec3 direction = normalize((\\n    modelMatrix * vec4(lightDirection, 1.0)\\n  ).xyz);\\n\\n  float diffuse = max(\\n    dot(normal, direction)\\n  , 0.0);\\n\\n  return max(\\n    light * diffuse * surface\\n  , vec3(0.0));\\n}\\n\\n\";"},"lineCount":1}},"error":null,"hash":"a65f757984c9d7bdd4908b7ddb91bb5e","cacheData":{"env":{}}}