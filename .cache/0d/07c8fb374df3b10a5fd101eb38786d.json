{"id":"js/libs/glsl/fragment.glsl","dependencies":[{"name":"E:\\MMI\\PTUT\\Site-ID\\package.json","includedInParent":true,"mtime":1612117417344}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nvarying vec2 vUv;\\n\\nuniform sampler2D imagebw;\\nuniform sampler2D imagergb;\\nuniform sampler2D displacement;\\n\\nuniform float time;\\n// uniform float _rot;\\nuniform float dispFactor;\\nuniform float effectFactor;\\nuniform float alpha;\\n\\n// vec2 rotate(vec2 v, float a) {\\n  //  float s = sin(a);\\n  //  float c = cos(a);\\n  //  mat2 m = mat2(c, -s, s, c);\\n  //  return m * v;\\n// }\\n\\nvoid main(){\\n  \\n  vec2 uv=vUv;\\n  \\n  // uv -= 0.5;\\n  // vec2 rotUV = rotate(uv, _rot);\\n  // uv += 0.5;\\n\\n  //   vec4 displace = texture2D(displacement, vUv.yx);\\n  \\n  vec4 disp=texture2D(displacement,uv);\\n  // vec2 displacedUV = vec2(vUv.x, vUv.y + disp.r);\\n\\n  // displacedUV.y = mix(vUv.y, disp.r, 0.1);\\n  \\n  //   vec4 color = texture2D(image, displacedUV);\\n  \\n  vec2 distortedPosition=vec2(uv.x+dispFactor*(disp.r*effectFactor),uv.y);\\n  vec2 distortedPosition2=vec2(uv.x-(1.-dispFactor)*(disp.r*effectFactor),uv.y);\\n  \\n  vec4 _texture=texture2D(imagebw,distortedPosition);\\n  vec4 _texture2=texture2D(imagergb,distortedPosition2);\\n  \\n  vec4 finalTexture=mix(_texture,_texture2,dispFactor);\\n  \\n  // finalTexture.r = texture2D(imagergb, disp + vec2(.0, .0)).r;\\n  // finalTexture.g = texture2D(imagergb, disp + vec2(.0, -0.01)).g;\\n  // finalTexture.b = texture2D(imagergb, disp + vec2(.0, 0.02)).b;\\n\\n  finalTexture.a = alpha;\\n\\n  gl_FragColor=finalTexture;\\n  // gl_FragColor = disp;\\n\\n}\\n\\n// void main() {\\n//   vUv = uv;\\n\\n//   vec3 pos = position;\\n//   float noiseFreq = 3.5;\\n//   float noiseAmp = 0.15; \\n//   vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\\n//   pos.z += snoise(noisePos) * noiseAmp;\\n\\n//   gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// uniform float time;\\n// uniform float alpha;\\n// uniform float displaceHover;\\n// // uniform float progress;\\n// uniform sampler2D image;\\n// uniform sampler2D displacement;\\n// uniform sampler2D tDiffuse;\\n\\n// uniform vec2 resolution;\\n// uniform vec2 mouse;\\n// // uniform float u_Velo;\\n// // uniform int u_Type;\\n\\n// varying vec2 vUv;\\n// // varying vec4 vPosition;\\n\\n// void main(){\\n//   vec4 displace = texture2D(displacement, vUv.yx);\\n//   vec2 displacedUV = vec2(vUv.x, vUv.y + displace.r);\\n  \\n//   displacedUV.y = mix(vUv.y, displace.r, displaceHover);\\n  \\n//   vec4 color = texture2D(imagebw, displacedUV);\\n  \\n//   // color.r = texture2D(image, displacedUV + vec2(time*.002, time*0.03)).r;\\n//   // color.g = 0.;\\n//   // color.b = texture2D(image, displacedUV + vec2(time*.002, time*0.07)).b;\\n//   float activeRGB = displaceHover * 10.0;\\n//   // color.r = texture2D(imagebw, displacedUV + vec2(.0, 0.5)*activeRGB).r;\\n//   color.r = texture2D(imagebw, displacedUV + vec2(.0, -0.2) + vec2(.3, 0.)*activeRGB).r;\\n//   // color.r = texture2D(imagebw, displacedUV + vec2(.3, 0.)*activeRGB).r;\\n//   color.g = texture2D(imagebw, displacedUV + vec2(.0, -0.01)*activeRGB).g;\\n//   color.b = texture2D(imagebw, displacedUV + vec2(.0, 0.02)*activeRGB).b;\\n  \\n//   color.a = alpha;\\n  \\n// //   // // get small circle around mouse, with distances to it\\n// //   // float c=circle(uv,mouse,0.,.2);\\n// //   // // get texture 3 times, each time with a different offset, depending on mouse speed:\\n\\n// //   // float r=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.5)).x;\\n// //   // float g=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.525)).y;\\n// //   // float b=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.55)).z;\\n// //   // // combine it all to final output\\n// //   // color=vec4(r,g,b,1.);\\n  \\n// //   // vec2 newUV = mix(uv, mouse, circle); \\n// //   // color = texture2D(tDiffuse,newUV);\\n  \\n//   gl_FragColor=color;\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// float circle(vec2 uv,vec2 disc_center,float disc_radius,float border_size){\\n//   uv-=disc_center;\\n//   uv*=resolution;\\n//   float dist=sqrt(dot(uv,uv));\\n//   return smoothstep(disc_radius+border_size,disc_radius-border_size,dist);\\n// }\\n\\n// void main(){\\n//   vec2 newUV=vUv;\\n//   float c = circle(vUv,uMouse,0.,.2);\\n//   float r = texture2D(tDiffuse,newUV.xy+=c*(.1*.5)).x;\\n//   float g = texture2D(tDiffuse,newUV.xy+=c*(.1*.525)).y;\\n//   float b = texture2D(tDiffuse,newUV.xy+=c*(.1*.55)).z;\\n//   vec4 color = vec4(r,g,b,1.);\\n//   gl_FragColor = color;\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// float circle(vec2 uv,vec2 disc_center,float disc_radius,float border_size){\\n//   uv-=disc_center;\\n//   uv*=resolution;\\n//   float dist=sqrt(dot(uv,uv));\\n//   return smoothstep(disc_radius+border_size,disc_radius-border_size,dist);\\n// }\\n\\n// float map(float value,float min1,float max1,float min2,float max2){\\n//   return min2+(value-min1)*(max2-min2)/(max1-min1);\\n// }\\n\\n// float remap(float value,float inMin,float inMax,float outMin,float outMax){\\n//   return outMin+(outMax-outMin)*(value-inMin)/(inMax-inMin);\\n// }\\n\\n// float hash12(vec2 p){\\n//   float h=dot(p,vec2(127.1,311.7));\\n//   return fract(sin(h)*43758.5453123);\\n// }\\n\\n// // #define HASHSCALE3 vec3(.1031, .1030, .0973)\\n// vec2 hash2d(vec2 p)\\n// {\\n//   vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.1030,.0973));\\n//   p3+=dot(p3,p3.yzx+19.19);\\n//   return fract((p3.xx+p3.yz)*p3.zy);\\n// }\\n\\n// void main(){\\n//   vec2 newUV=v_uv;\\n//   vec4 color=vec4(1.,0.,0.,1.);\\n  \\n//   // colorful\\n//   // if(uType==0){\\n//     float c=circle(newUV,uMouse,0.,.2);\\n//     float r=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.5)).x;\\n//     float g=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.525)).y;\\n//     float b=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.55)).z;\\n//     color=vec4(r,g,b,1.);\\n//   // }\\n  \\n//   // zoom\\n//   // if(uType==1){\\n//     // \\tfloat c = circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;\\n//     // \\tvec2 offsetVector = normalize(uMouse - v_uv);\\n//     // \\tvec2 warpedUV = mix(v_uv, uMouse, c * 0.99); //power\\n//     // \\tcolor = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);\\n//   // }\\n  \\n//   // // zoom\\n//   // if(uType==2){\\n//     // \\tfloat hash = hash12(v_uv*10.);\\n//     // \\t// float c = -circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;\\n//     // \\t// vec2 offsetVector = -normalize(uMouse - v_uv);\\n//     // \\t// vec2 warpedUV = mix(v_uv, uMouse, c * 0.6); //power\\n//     // \\t// vec2 warpedUV1 = mix(v_uv, uMouse, c * 0.3); //power\\n//     // \\t// vec2 warpedUV2 = mix(v_uv, uMouse, c * 0.1); //power\\n//     // \\t// color = vec4(\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV ).r,\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV1 ).g,\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV2 ).b,\\n//     // \\t// \\t1.);\\n//     // \\t// color = vec4(,0.,0.,1.);\\n//     // \\tfloat c = circle(newUV, uMouse, 0.0, 0.1+uVelo*0.01)*10.*uVelo;\\n//     // \\tvec2 offsetVector = normalize(uMouse - v_uv);\\n//     // \\t// vec2 warpedUV = mix(v_uv, uMouse,  20.*hash*c); //power\\n//     // \\tvec2 warpedUV = v_uv + vec2(hash - 0.5)*c; //power\\n//     // \\tcolor = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);\\n//   // }\\n  \\n//   gl_FragColor=color;\\n// }\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":7529},"source":"js/libs/glsl/fragment.glsl","original":{"line":1,"column":0}}],"sources":{"js/libs/glsl/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nvarying vec2 vUv;\\n\\nuniform sampler2D imagebw;\\nuniform sampler2D imagergb;\\nuniform sampler2D displacement;\\n\\nuniform float time;\\n// uniform float _rot;\\nuniform float dispFactor;\\nuniform float effectFactor;\\nuniform float alpha;\\n\\n// vec2 rotate(vec2 v, float a) {\\n  //  float s = sin(a);\\n  //  float c = cos(a);\\n  //  mat2 m = mat2(c, -s, s, c);\\n  //  return m * v;\\n// }\\n\\nvoid main(){\\n  \\n  vec2 uv=vUv;\\n  \\n  // uv -= 0.5;\\n  // vec2 rotUV = rotate(uv, _rot);\\n  // uv += 0.5;\\n\\n  //   vec4 displace = texture2D(displacement, vUv.yx);\\n  \\n  vec4 disp=texture2D(displacement,uv);\\n  // vec2 displacedUV = vec2(vUv.x, vUv.y + disp.r);\\n\\n  // displacedUV.y = mix(vUv.y, disp.r, 0.1);\\n  \\n  //   vec4 color = texture2D(image, displacedUV);\\n  \\n  vec2 distortedPosition=vec2(uv.x+dispFactor*(disp.r*effectFactor),uv.y);\\n  vec2 distortedPosition2=vec2(uv.x-(1.-dispFactor)*(disp.r*effectFactor),uv.y);\\n  \\n  vec4 _texture=texture2D(imagebw,distortedPosition);\\n  vec4 _texture2=texture2D(imagergb,distortedPosition2);\\n  \\n  vec4 finalTexture=mix(_texture,_texture2,dispFactor);\\n  \\n  // finalTexture.r = texture2D(imagergb, disp + vec2(.0, .0)).r;\\n  // finalTexture.g = texture2D(imagergb, disp + vec2(.0, -0.01)).g;\\n  // finalTexture.b = texture2D(imagergb, disp + vec2(.0, 0.02)).b;\\n\\n  finalTexture.a = alpha;\\n\\n  gl_FragColor=finalTexture;\\n  // gl_FragColor = disp;\\n\\n}\\n\\n// void main() {\\n//   vUv = uv;\\n\\n//   vec3 pos = position;\\n//   float noiseFreq = 3.5;\\n//   float noiseAmp = 0.15; \\n//   vec3 noisePos = vec3(pos.x * noiseFreq + uTime, pos.y, pos.z);\\n//   pos.z += snoise(noisePos) * noiseAmp;\\n\\n//   gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// uniform float time;\\n// uniform float alpha;\\n// uniform float displaceHover;\\n// // uniform float progress;\\n// uniform sampler2D image;\\n// uniform sampler2D displacement;\\n// uniform sampler2D tDiffuse;\\n\\n// uniform vec2 resolution;\\n// uniform vec2 mouse;\\n// // uniform float u_Velo;\\n// // uniform int u_Type;\\n\\n// varying vec2 vUv;\\n// // varying vec4 vPosition;\\n\\n// void main(){\\n//   vec4 displace = texture2D(displacement, vUv.yx);\\n//   vec2 displacedUV = vec2(vUv.x, vUv.y + displace.r);\\n  \\n//   displacedUV.y = mix(vUv.y, displace.r, displaceHover);\\n  \\n//   vec4 color = texture2D(imagebw, displacedUV);\\n  \\n//   // color.r = texture2D(image, displacedUV + vec2(time*.002, time*0.03)).r;\\n//   // color.g = 0.;\\n//   // color.b = texture2D(image, displacedUV + vec2(time*.002, time*0.07)).b;\\n//   float activeRGB = displaceHover * 10.0;\\n//   // color.r = texture2D(imagebw, displacedUV + vec2(.0, 0.5)*activeRGB).r;\\n//   color.r = texture2D(imagebw, displacedUV + vec2(.0, -0.2) + vec2(.3, 0.)*activeRGB).r;\\n//   // color.r = texture2D(imagebw, displacedUV + vec2(.3, 0.)*activeRGB).r;\\n//   color.g = texture2D(imagebw, displacedUV + vec2(.0, -0.01)*activeRGB).g;\\n//   color.b = texture2D(imagebw, displacedUV + vec2(.0, 0.02)*activeRGB).b;\\n  \\n//   color.a = alpha;\\n  \\n// //   // // get small circle around mouse, with distances to it\\n// //   // float c=circle(uv,mouse,0.,.2);\\n// //   // // get texture 3 times, each time with a different offset, depending on mouse speed:\\n\\n// //   // float r=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.5)).x;\\n// //   // float g=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.525)).y;\\n// //   // float b=texture2D(tDiffuse,uv.xy+=(mouseVelocity*.55)).z;\\n// //   // // combine it all to final output\\n// //   // color=vec4(r,g,b,1.);\\n  \\n// //   // vec2 newUV = mix(uv, mouse, circle); \\n// //   // color = texture2D(tDiffuse,newUV);\\n  \\n//   gl_FragColor=color;\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// float circle(vec2 uv,vec2 disc_center,float disc_radius,float border_size){\\n//   uv-=disc_center;\\n//   uv*=resolution;\\n//   float dist=sqrt(dot(uv,uv));\\n//   return smoothstep(disc_radius+border_size,disc_radius-border_size,dist);\\n// }\\n\\n// void main(){\\n//   vec2 newUV=vUv;\\n//   float c = circle(vUv,uMouse,0.,.2);\\n//   float r = texture2D(tDiffuse,newUV.xy+=c*(.1*.5)).x;\\n//   float g = texture2D(tDiffuse,newUV.xy+=c*(.1*.525)).y;\\n//   float b = texture2D(tDiffuse,newUV.xy+=c*(.1*.55)).z;\\n//   vec4 color = vec4(r,g,b,1.);\\n//   gl_FragColor = color;\\n// }\\n\\n// =================================================================================\\n// =================================================================================\\n\\n// float circle(vec2 uv,vec2 disc_center,float disc_radius,float border_size){\\n//   uv-=disc_center;\\n//   uv*=resolution;\\n//   float dist=sqrt(dot(uv,uv));\\n//   return smoothstep(disc_radius+border_size,disc_radius-border_size,dist);\\n// }\\n\\n// float map(float value,float min1,float max1,float min2,float max2){\\n//   return min2+(value-min1)*(max2-min2)/(max1-min1);\\n// }\\n\\n// float remap(float value,float inMin,float inMax,float outMin,float outMax){\\n//   return outMin+(outMax-outMin)*(value-inMin)/(inMax-inMin);\\n// }\\n\\n// float hash12(vec2 p){\\n//   float h=dot(p,vec2(127.1,311.7));\\n//   return fract(sin(h)*43758.5453123);\\n// }\\n\\n// // #define HASHSCALE3 vec3(.1031, .1030, .0973)\\n// vec2 hash2d(vec2 p)\\n// {\\n//   vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.1030,.0973));\\n//   p3+=dot(p3,p3.yzx+19.19);\\n//   return fract((p3.xx+p3.yz)*p3.zy);\\n// }\\n\\n// void main(){\\n//   vec2 newUV=v_uv;\\n//   vec4 color=vec4(1.,0.,0.,1.);\\n  \\n//   // colorful\\n//   // if(uType==0){\\n//     float c=circle(newUV,uMouse,0.,.2);\\n//     float r=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.5)).x;\\n//     float g=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.525)).y;\\n//     float b=texture2D(tDiffuse,newUV.xy+=c*(uVelo*.55)).z;\\n//     color=vec4(r,g,b,1.);\\n//   // }\\n  \\n//   // zoom\\n//   // if(uType==1){\\n//     // \\tfloat c = circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;\\n//     // \\tvec2 offsetVector = normalize(uMouse - v_uv);\\n//     // \\tvec2 warpedUV = mix(v_uv, uMouse, c * 0.99); //power\\n//     // \\tcolor = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);\\n//   // }\\n  \\n//   // // zoom\\n//   // if(uType==2){\\n//     // \\tfloat hash = hash12(v_uv*10.);\\n//     // \\t// float c = -circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;\\n//     // \\t// vec2 offsetVector = -normalize(uMouse - v_uv);\\n//     // \\t// vec2 warpedUV = mix(v_uv, uMouse, c * 0.6); //power\\n//     // \\t// vec2 warpedUV1 = mix(v_uv, uMouse, c * 0.3); //power\\n//     // \\t// vec2 warpedUV2 = mix(v_uv, uMouse, c * 0.1); //power\\n//     // \\t// color = vec4(\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV ).r,\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV1 ).g,\\n//       // \\t// \\ttexture2D(tDiffuse,warpedUV2 ).b,\\n//     // \\t// \\t1.);\\n//     // \\t// color = vec4(,0.,0.,1.);\\n//     // \\tfloat c = circle(newUV, uMouse, 0.0, 0.1+uVelo*0.01)*10.*uVelo;\\n//     // \\tvec2 offsetVector = normalize(uMouse - v_uv);\\n//     // \\t// vec2 warpedUV = mix(v_uv, uMouse,  20.*hash*c); //power\\n//     // \\tvec2 warpedUV = v_uv + vec2(hash - 0.5)*c; //power\\n//     // \\tcolor = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);\\n//   // }\\n  \\n//   gl_FragColor=color;\\n// }\";"},"lineCount":null}},"error":null,"hash":"4cf02969a1c06874d403fedb901c70f3","cacheData":{"env":{}}}